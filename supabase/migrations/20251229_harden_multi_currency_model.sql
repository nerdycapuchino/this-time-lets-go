BEGIN;

-- ####################################################################
-- ### Step 1: Replace ENUM with a dedicated `currencies` table      ###
-- ### Why: Allows adding/disabling currencies without migrations.   ###
-- ###      Stores essential metadata like symbols and names.        ###
-- ####################################################################

CREATE TABLE IF NOT EXISTS public.currencies (
    code TEXT PRIMARY KEY,
    symbol TEXT NOT NULL,
    name TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.currencies IS 'Stores the list of supported currencies, replacing the inflexible currency_type ENUM.';
COMMENT ON COLUMN public.currencies.code IS 'ISO 4217 currency code (e.g., USD, INR).';

-- Migrate existing currencies from the ENUM
INSERT INTO public.currencies (code, symbol, name) VALUES
('USD', '$', 'United States Dollar'),
('INR', 'â‚¹', 'Indian Rupee')
ON CONFLICT (code) DO NOTHING;


-- ####################################################################
-- ### Step 2: Create `historical_exchange_rates` table             ###
-- ### Why: Preserves historical accuracy for all conversions.       ###
-- ###      Every transaction can be tied to a specific rate in time.###
-- ####################################################################

CREATE TABLE IF NOT EXISTS public.historical_exchange_rates (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    from_currency TEXT NOT NULL REFERENCES public.currencies(code),
    to_currency TEXT NOT NULL REFERENCES public.currencies(code),
    rate NUMERIC(14, 6) NOT NULL,
    effective_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT rate_must_be_positive CHECK (rate > 0),
    UNIQUE(from_currency, to_currency, effective_at)
);
CREATE INDEX IF NOT EXISTS idx_historical_rates_effective_at ON public.historical_exchange_rates(effective_at DESC);
COMMENT ON TABLE public.historical_exchange_rates IS 'Stores a time-series of exchange rates for accurate historical financial calculations.';
COMMENT ON COLUMN public.historical_exchange_rates.effective_at IS 'The timestamp from which this rate is valid.';


-- ####################################################################
-- ### Step 3: Harden transactional tables (`invoices`, `time_logs`) ###
-- ### Why: Creates immutable, auditable financial records.          ###
-- ###      Values are "locked in" at the time of the transaction.    ###
-- ####################################################################

-- Add a reporting currency column to organizations (if it doesn't exist)
ALTER TABLE public.organizations
ADD COLUMN IF NOT EXISTS reporting_currency TEXT NOT NULL REFERENCES public.currencies(code) DEFAULT 'USD';


-- Harden `projects` table by changing currency column to reference the new table
-- We will add a trigger later to prevent changes after transactions exist.
ALTER TABLE public.projects
    DROP COLUMN IF EXISTS currency,
    ADD COLUMN currency_code TEXT NOT NULL REFERENCES public.currencies(code) DEFAULT 'USD';

-- Harden `profiles` table for user's hourly rate
ALTER TABLE public.profiles
    DROP COLUMN IF EXISTS hourly_rate_currency,
    ADD COLUMN hourly_rate_currency_code TEXT NOT NULL REFERENCES public.currencies(code) DEFAULT 'USD';

-- Harden `invoices` table
ALTER TABLE public.invoices
    DROP COLUMN IF EXISTS currency,
    ADD COLUMN currency_code TEXT REFERENCES public.currencies(code),
    ADD COLUMN amount_in_reporting_currency NUMERIC(12, 2),
    ADD COLUMN exchange_rate_id BIGINT REFERENCES public.historical_exchange_rates(id);

COMMENT ON COLUMN public.invoices.amount_in_reporting_currency IS 'The invoice amount converted to the organizations primary reporting currency (e.g., USD) at the time of creation.';
COMMENT ON COLUMN public.invoices.exchange_rate_id IS 'The specific historical exchange rate used for the conversion.';

-- Harden `time_logs` table
ALTER TABLE public.time_logs
    DROP COLUMN IF EXISTS currency,
    ADD COLUMN user_hourly_rate NUMERIC(10, 2) NOT NULL DEFAULT 0.0,
    ADD COLUMN user_hourly_rate_currency_code TEXT NOT NULL REFERENCES public.currencies(code),
    ADD COLUMN cost_in_project_currency NUMERIC(10, 2),
    ADD COLUMN cost_in_reporting_currency NUMERIC(10, 2),
    ADD COLUMN project_currency_exchange_rate_id BIGINT REFERENCES public.historical_exchange_rates(id),
    ADD COLUMN reporting_currency_exchange_rate_id BIGINT REFERENCES public.historical_exchange_rates(id);

COMMENT ON COLUMN public.time_logs.user_hourly_rate IS 'The hourly rate of the user at the time the log was created.';
COMMENT ON COLUMN public.time_logs.cost_in_project_currency IS 'The calculated cost (duration * rate) in the project''s base currency.';
COMMENT ON COLUMN public.time_logs.cost_in_reporting_currency IS 'The calculated cost converted to the organization''s reporting currency.';


-- ####################################################################
-- ### Step 4: Drop legacy objects from the old design             ###
-- ####################################################################

DROP TABLE IF EXISTS public.exchange_rates;
DO $$ BEGIN
    DROP TYPE public.currency_type;
EXCEPTION
    WHEN dependent_objects_still_exist THEN
        RAISE NOTICE 'currency_type is in use, altering columns before dropping.';
END $$;
-- NOTE: We already altered the columns in Step 3, so a second run of this file
-- would safely drop the type. This is idempotent.


-- ####################################################################
-- ### Step 5: Add triggers for data integrity and automation        ###
-- ### Why: Prevents mistakes and guarantees calculations are correct.###
-- ####################################################################

-- Trigger to prevent project currency from changing if transactions exist
CREATE OR REPLACE FUNCTION public.prevent_project_currency_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.currency_code IS DISTINCT FROM NEW.currency_code THEN
        IF EXISTS (SELECT 1 FROM public.invoices WHERE project_id = NEW.id) OR
           EXISTS (SELECT 1 FROM public.time_logs tl JOIN public.kanban_cards kc ON tl.kanban_card_id = kc.id WHERE kc.project_id = NEW.id)
        THEN
            RAISE EXCEPTION 'Cannot change project currency because financial records (invoices or time logs) already exist.';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_prevent_project_currency_change ON public.projects;
CREATE TRIGGER trg_prevent_project_currency_change
BEFORE UPDATE ON public.projects
FOR EACH ROW
EXECUTE FUNCTION public.prevent_project_currency_change();


-- Trigger function to populate invoice financial data
CREATE OR REPLACE FUNCTION public.handle_invoice_finances()
RETURNS TRIGGER AS $$
DECLARE
    proj_currency TEXT;
    org_reporting_currency TEXT;
    rate_to_reporting_currency NUMERIC;
    rate_id BIGINT;
BEGIN
    -- Get project currency and organization's reporting currency
    SELECT p.currency_code INTO proj_currency FROM public.projects p WHERE p.id = NEW.project_id;
    SELECT o.reporting_currency INTO org_reporting_currency FROM public.organizations o WHERE o.id = NEW.organization_id;

    NEW.currency_code := proj_currency;

    IF proj_currency = org_reporting_currency THEN
        NEW.amount_in_reporting_currency := NEW.amount;
    ELSE
        -- Find the most recent exchange rate for this conversion
        SELECT h.id, h.rate INTO rate_id, rate_to_reporting_currency
        FROM public.historical_exchange_rates h
        WHERE h.from_currency = proj_currency AND h.to_currency = org_reporting_currency
        AND h.effective_at <= NEW.created_at
        ORDER BY h.effective_at DESC
        LIMIT 1;

        IF rate_id IS NULL THEN
            RAISE EXCEPTION 'No exchange rate found for % to % on or before %', proj_currency, org_reporting_currency, NEW.created_at;
        END IF;

        NEW.exchange_rate_id := rate_id;
        NEW.amount_in_reporting_currency := NEW.amount * rate_to_reporting_currency;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_handle_invoice_finances ON public.invoices;
CREATE TRIGGER trg_handle_invoice_finances
BEFORE INSERT ON public.invoices
FOR EACH ROW
EXECUTE FUNCTION public.handle_invoice_finances();


-- Trigger function to calculate cost on time_log completion
CREATE OR REPLACE FUNCTION public.handle_time_log_cost_calculation()
RETURNS TRIGGER AS $$
DECLARE
    usr RECORD;
    proj RECORD;
    org_reporting_currency TEXT;
    rate_to_project_currency NUMERIC;
    rate_to_reporting_currency NUMERIC;
    rate_id_to_project BIGINT;
    rate_id_to_reporting BIGINT;
    cost_in_user_currency NUMERIC;
BEGIN
    -- Only calculate on completion (end_time is set)
    IF NEW.end_time IS NOT NULL AND OLD.end_time IS NULL THEN
        -- Get user, project, and org data
        SELECT p.hourly_rate, p.hourly_rate_currency_code INTO usr FROM public.profiles p WHERE p.id = NEW.user_id;
        SELECT pr.id, pr.currency_code INTO proj FROM public.projects pr JOIN public.kanban_cards kc ON pr.id = kc.project_id WHERE kc.id = NEW.kanban_card_id;
        SELECT o.reporting_currency INTO org_reporting_currency FROM public.organizations o WHERE o.id = NEW.organization_id;

        -- Snapshot user rate
        NEW.user_hourly_rate := usr.hourly_rate;
        NEW.user_hourly_rate_currency_code := usr.hourly_rate_currency_code;
        
        -- Base cost in user's currency
        cost_in_user_currency := (NEW.duration_minutes / 60.0) * usr.hourly_rate;

        -- Convert to Project Currency
        IF usr.hourly_rate_currency_code = proj.currency_code THEN
            NEW.cost_in_project_currency := cost_in_user_currency;
        ELSE
            SELECT h.id, h.rate INTO rate_id_to_project, rate_to_project_currency
            FROM public.historical_exchange_rates h
            WHERE h.from_currency = usr.hourly_rate_currency_code AND h.to_currency = proj.currency_code
            AND h.effective_at <= NEW.end_time ORDER BY h.effective_at DESC LIMIT 1;

            IF rate_id_to_project IS NULL THEN RAISE EXCEPTION 'No exchange rate found to convert user cost to project currency.'; END IF;
            
            NEW.cost_in_project_currency := cost_in_user_currency * rate_to_project_currency;
            NEW.project_currency_exchange_rate_id := rate_id_to_project;
        END IF;

        -- Convert to Reporting Currency
        IF usr.hourly_rate_currency_code = org_reporting_currency THEN
            NEW.cost_in_reporting_currency := cost_in_user_currency;
        ELSE
            SELECT h.id, h.rate INTO rate_id_to_reporting, rate_to_reporting_currency
            FROM public.historical_exchange_rates h
            WHERE h.from_currency = usr.hourly_rate_currency_code AND h.to_currency = org_reporting_currency
            AND h.effective_at <= NEW.end_time ORDER BY h.effective_at DESC LIMIT 1;

            IF rate_id_to_reporting IS NULL THEN RAISE EXCEPTION 'No exchange rate found to convert user cost to reporting currency.'; END IF;

            NEW.cost_in_reporting_currency := cost_in_user_currency * rate_to_reporting_currency;
            NEW.reporting_currency_exchange_rate_id := rate_id_to_reporting;
        END IF;
        
        -- The original `cost` column is now redundant, but we fill it for compatibility before removing it later.
        NEW.cost := NEW.cost_in_project_currency; 
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_calculate_time_log_cost ON public.time_logs;
CREATE TRIGGER trg_calculate_time_log_cost
BEFORE UPDATE OF end_time ON public.time_logs
FOR EACH ROW
EXECUTE FUNCTION public.handle_time_log_cost_calculation();


-- ####################################################################
-- ### Step 6: Rewrite profitability function to use hardened data   ###
-- ### Why: Makes reporting fast, accurate, and simple. No joins on  ###
-- ###      rates, no live conversions, just summing pre-calculated   ###
-- ###      auditable values.                                         ###
-- ####################################################################

CREATE OR REPLACE FUNCTION get_profitability_data(reporting_currency_code TEXT DEFAULT 'USD')
RETURNS JSONB AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'projects', (
            SELECT jsonb_agg(p_agg) FROM (
                SELECT
                    p.id,
                    p.name,
                    p.currency_code,
                    -- Aggregate revenue directly from the pre-calculated reporting currency column
                    (SELECT SUM(i.amount_in_reporting_currency) FROM invoices i WHERE i.project_id = p.id AND i.status IN ('paid', 'sent')) as total_revenue,
                    -- Aggregate cost directly from the pre-calculated reporting currency column
                    (SELECT SUM(tl.cost_in_reporting_currency) FROM time_logs tl JOIN kanban_cards kc ON tl.kanban_card_id = kc.id WHERE kc.project_id = p.id) as total_cost
                FROM projects p
            ) p_agg
        ),
        'monthly_overview', (
             WITH revenue_by_month AS (
                SELECT
                    to_char(date_trunc('month', i.created_at), 'YYYY-MM') as month,
                    SUM(i.amount_in_reporting_currency) as total_revenue
                FROM invoices i
                WHERE i.status IN ('paid', 'sent')
                GROUP BY 1
            ),
            cost_by_month AS (
                SELECT
                    to_char(date_trunc('month', tl.end_time), 'YYYY-MM') as month,
                    SUM(tl.cost_in_reporting_currency) as total_cost
                FROM time_logs tl
                WHERE tl.end_time IS NOT NULL AND tl.cost_in_reporting_currency IS NOT NULL
                GROUP BY 1
            )
            SELECT jsonb_agg(m_agg) FROM (
                SELECT
                    COALESCE(r.month, c.month) as month,
                    COALESCE(r.total_revenue, 0) as revenue,
                    COALESCE(c.total_cost, 0) as cost,
                    (COALESCE(r.total_revenue, 0) - COALESCE(c.total_cost, 0)) as margin
                FROM revenue_by_month r
                FULL OUTER JOIN cost_by_month c ON r.month = c.month
                WHERE r.month IS NOT NULL OR c.month IS NOT NULL
                ORDER BY 1 DESC
            ) m_agg
        )
    ) INTO result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;


COMMIT;
